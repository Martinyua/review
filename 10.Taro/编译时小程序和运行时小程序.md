编译类型和运行类型框架的优缺点：

| 框架                          | 优点                                                         | 缺点                                           |
| ----------------------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 编译类型（nananchi、taro1/2） | 运行时性能损耗低 开发者所写即所得(编译前后代码的对应关系清晰) | 语法限制高（`jsx`)                             |
| 运行类型（remax、taro)        | 几乎没有任何语法约束                                         | 数据传输量大 页面上存在大量的监听器 性能损耗大 |

编译时框架：运行时性能损耗小，开发者所写即所得（前后代码关系对应明确）。缺点是语法限制比较大（`jsx`）。运行时框架没有任何语法限制，但是页面传输数据量大且存在大量的监听器。性能损耗大	

## 社区不仅有编译时的小程序框架，还有运行时的小程序框架，有没有了解过，怎么实现的
小程序框架 Rax/Taro/uni-app；Taro框架相比原生小程序来说，支持React规范，jsx语法，通过内置构建系统和wepack支持对less和sass，以及es6的语法支持；

Taro是基于编译时的转换类框架，通过编译分析，将React语法转换成原生代码，(将React代码本质通过babel（babel/parse）词法分析生成令牌流，根据令牌流生成语法分析树，使用babel/traverse对AST进行删除，增添节点等操作，最后通过babel/generator将AST转换成字符串代码，在这一过程中可以生成source-map；)编译时的优点在于，因为代码的转换发生在编译过程，因此运行是性能消耗是比较小的；另外也是因为要实现1：1还原小程序代码，对编译框架要求很高，就有一定的语法限制，比如一个条件语句中不能写很多return，需要遵循小程序开发规范，一个文件中定义一个组件类。

Rax是支持编译时和运行时共存的，在Rax中，运行时本质上接近富文本渲染，逻辑层将一个和节点渲染信息相关的组件树传递给视图层，视图层通过节点类型判断然后进行视图渲染；在逻辑层使用无限制语法规则，return jsx代码中生成是节点的信息，逻辑维护VDOM时，首先模拟dom中appendChild等dom操作，另外就是模拟事件，在逻辑层每个节点类会继承自EventTarget基类，通过节点id作为标识去收集需要监听的事件，当视图层通过action触发某个节点事件后，再通过原生小程序event.currentTarget.dataset.nodeId获取目标节点的id，最终触发目标回调。运行时方案虽然没有任何语法限制，劣势在于数据量传输大，需要将整个树从逻辑层传输到视图层；页面需要大量监听器，模板递归渲染，如果使用原生框架，在渲染前就知道大概页面结构，来进行优化。因此，对于一些简单的组件使用运行时的写法（和React写法类似），对于复杂的组件（要求较高的交互性），通过编译方案开发这个组件，然后在运行时项目中引入使用。