### 性能问题

* 因为逻辑层和渲染层的线程是分开的。所以数据的传输需要通过native的中转。频繁触发数据更新会耗费大量资源。所以小程序官方推荐减少触发频率，必要的时候可以使用防抖、截流函数。

* 为什么不可以使用dom

  * 小程序这样的双线程结构，若真能允许使用者操作 DOM 结构，那么每次对 DOM 增删改查的操作，都会引发线程通信问题，只能让调用过程非常缓慢，这个设计就失去了意义。

### 引发性能问题

* **`setData`传递大量的新数据。**因为逻辑层执行 `JSON.stringify` 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过`evaluateJavascript` 执行脚本将数据传输到渲染层。
* **频繁的`setData`。**频繁的执行 `setData` 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。
* 过多的页面节点数。页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。
* 小程序是基于双线程模型，那就意味着任何数据传递都是线层间的通信，也就是统一都会有一定的延迟，不像传统web，当界面需要更新时，通过调用更新接口UI就会同步地渲染出来。在小程序的架构里，一切都是异步。
* 除了逻辑层与渲染层之间的通信有延时，各层与客户端原生交互同样是有延时的。

### 小程序更新视图数据的通信流程

  每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：

  1. 小程序逻辑层调用宿主环境的 setData 方法。
  2. 逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过evaluateJavascript 执行脚本将数据传输到渲染层。
  3. 渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。
  4. WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。