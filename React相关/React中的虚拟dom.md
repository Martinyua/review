## 虚拟DOM

> 虚拟DOM如何构建，在《jsx原理》一节已经说明。

> 从最早的纯静态页面 --> jQuery --> MVVM框架，**研发模式不断演进的背后，恰恰蕴含着前端人对“DOM操作”这一核心动作的持续思考和改进。**

### what && how

**虚拟DOM是什么**

虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个**映射缓存**，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 **JS 对象**。

**虚拟DOM如何工作**

- **挂载阶段**：React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；

- **更新阶段**：页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM。

  ![Lark20201106-192055.png](https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMeWADhSdAABuVFS6_bo480.png)

  当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“**差量更新**”。

### why：虚拟DOM价值所在

- **虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。**
- 虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。【**它打开了函数式的UI编程的大门，即UI = f(data)这种构建UI的方式。**】
- 跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是iOS 界面、安卓界面、小程序......同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和1是高度呼应的。【**可以将JS对象渲染到浏览器DOM以外的环境中，也就是支持了跨平台开发，比如ReactNative。**】

### 注意：React选用虚拟DOM用意并非性能

> 很多人认为，**React 选用虚拟DOM，是为了更好的性能**，但其实React官方从未提及。

> **性能问题**属于前端领域复杂度比较高的问题。当我们量化性能的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论。

**React的基本思维模式**是：每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。

两个工作流对比：

- 对于innerHTML，分为两步：①动态生成HTML字符串（构建真实的DOM）②旧的DOM元素整体被新的DOM元素替换
- 对于虚拟DOM，分为三步：①构建新的虚拟DOM树②通过diff对比出新旧两棵树的差异③差量更新DOM

**性能对比分析**

- innerHTML的步骤①，虚拟DOM的步骤①②属于 JS 范畴的行为，这两者比较：动态生成 HTML 字符串的过程本质是对字符串的拼接，对性能的消耗是有限的；而虚拟 DOM 的构建和 diff 过程逻辑则相对复杂，它不可避免地涉及递归、遍历等耗时操作。因此在 JS 行为这个层面，innerHTML胜出。
- innerHTML的步骤②，虚拟DOM的步骤③ 都属于 DOM 范畴的行为，两者具备可比性，innerHTML是**全量更新**，而虚拟 DOM 是**差量更新**。对于数据内容变化非常大，促使差量更新计算出来的结果和全量更新极为接近；而对于数据内容变化很小的情况，显然差量更新占优。
- 补充：**虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级**，极少量的 DOM 操作耗费的性能足以支撑大量的 JS 计算。

### 拓展：性能层面的优化

除了差量更新以外，“**批量更新**”也是虚拟 DOM 在性能方面所做的一个重要努力：**“批量更新”在通用虚拟 DOM 库里是由 batch 函数来处理的**。在差量更新速度非常快的情况下（比如极短的时间里多次操作同一个 DOM），用户实际上只能看到最后一次更新的效果。这种场景下，前面几次的更新动作虽然意义不大，但都会触发重渲染流程，带来大量不必要的高耗能操作。

这时就需要请 batch 来帮忙了，**batch 的作用是缓冲每次生成的补丁集**，它会把收集到的多个补丁集暂存到队列中，再将最终的结果交给渲染函数，最终实现集中化的 DOM 批量更新。

