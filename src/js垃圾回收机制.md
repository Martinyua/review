## 4.23，js垃圾回收机制

* *变量的生命周期**

  * 当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。

* **垃圾回收原理**

  * **标记清除**

    * **工作原理**：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

    * **工作流程**:

      1. 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。

      2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。

      3. 再被加上标记的会被视为准备删除的变量。

      4. 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

  * **引用计数**

    * **工作原理**：跟踪记录每个值被引用的次数。

    * **工作流程**：

      1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。

      2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.

      3. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数1.

      4. 当引用次数变成0时，说明没办法访问这个值了。

      5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

    该方式会引起内存泄漏的原因是它不能解决循环引用的问题。

* **内存泄漏**

  * 意外的全局变量引起的内存泄漏。
  * 闭包引起的内存泄漏
  *  没有清理的DOM元素引用
  * 被遗忘的定时器或者回调

* **内部优化的算法**
  * **分代回收**——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”（），并且很少接受检查。
  * **增量回收**——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。