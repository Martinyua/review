第一版

浏览器的五个进程：浏览器进程，渲染进程，GPU进程，网络进程，插件进程

- 浏览器进程主要负责用户交互，子进程管理和文件存储等
- 网络进程主要是面向渲染进程和浏览器进程提供的下载服务
- 渲染进程主要是把下载下来的HTML，CSS，JS等解析为可交互界面，渲染进程运行在沙盒中



1. **用户输入**

   1. 浏览器进程会判断是搜索内容还是请求的URL
   2. 如果符合URL规则，会加上协议，合成完整的URL
   3. 浏览器进程然后等待文档提交阶段

2. **URL请求**

   1. 浏览器进程通**过进程间通信**（IPC）把URL发送到网络进程
   2. **查强缓存**。如果命中了就直接加载资源
   3. 若没有命中强缓存，就进入到**网络请求流程**。进行**DNS解析**（会先查找本地是否有DNS缓存），获取IP和端口
   4. **建立TCP连接**，**三次握手**，**如果协议是HTTPS，还需要建立TLS**
   5. **发起HTTP请求**：构建请求行，请求头，并把cookie等数据加到请求头中。然后发送构建的请求信息。
   6. 浏览器收到返回的响应头后，开始解析响头
      1. **重定向**，状态码为301或302。在响应头的location字段中告诉d要重定向的URL
      2. **响应行状态码为200**。表示可以继续处理该请求。然后进行响应数据类型的判断，返回的响应体数据类型`content-type`如果为`application/octet-stream`。则为下载类型。表示该请求提交给浏览器的下载管理器。URL请求导航结束。若为`text/html`则继续

   

3. **提交文档**

   1. 文档提交指URL请求的**响应体的数据**
   2. 提交文档的消息由浏览器进程发出，让网络进程和渲染进程建立数据传输的管道。完成后渲染进程“确认提交”的信息给浏览器进程。然后浏览器进程开始更新页面状态

4. **渲染阶段**![img](https://img-blog.csdn.net/20180330135750219)

   1. 准备渲染流程：

      1. 默认情况下，`chorme`会为每一个页面分配一个`渲染流程`。但是**同一站点**（根域名加上协议相同，端口和子域可以不同），新页面会共用一个`渲染流程`。

   2. 构建DOM树

      1. 浏览器无法直接理解和使用HTML，所以需要将HTML转化为浏览器能够理解的**DOM树。**

   3. 样式计算

      1. 把`css`转换为浏览器能够理解的结构——**结构化样式表**（`styleSheets`)
      2. 标准化属性值。如 2em ->32px。转换为渲染引擎能够理解的，标准化的计算值。
      3. 计算出DOM树中每个节点的**具体样式**`computedStyle`（涉及继承和层叠）

   4. 布局阶段

      1. 计算出DOM树中可见元素的**几何位置**
      2. 创建布局树`Layout Tree`。在显示之前，我们还要额外的构建一棵只包含可见元素的布局树 DOM树 + `computedStyle` = `Layout Tree`

   5. 开始绘制

      1. **分层**

         1. 渲染引擎为特定的节点生成专用的图层，并且生成一棵对应的图层树。  （`LayerTree`）

      2. **图层绘制**

         1. 渲染引擎会把图层的绘制拆分成**很多小的绘制指令**，即一个**绘制列表**

      3. **栅格化操作（raster）**

         1. 主线程将绘制列表提交给合成线程
         2. 合成线程将**图层**划分 为**图块**
         3. 合成线程将视口附近的**图块**来优先生产**位图**（这个过程就是栅格化）
         4. GPU进程中，执行生成图块的位图，并且保存在GPU内存中

         

   6. **合成和显示**

      栅格化操作完成后，合成线程会生成一个绘制命令，即“`DrawQuad`”，发送给浏览器进程，浏览器进程中有一个viz组件，更加`DrawQuad`命令将页面内容绘制到内存上，就生成了页面





### 主线程

   DOM Style Layout Layer Paint

   

### 重绘

   当布局树中的一些元素需要更新，而这些属性**只是影响外观，风格，而不会影响布局的操作**。就**没有布局和分层阶段**

### 重排

通过JS或CSS修改了元素的**几何位置属性**（尺寸，布局，隐藏）

**回流必将引起重绘，重绘不一定会引起回流**

### 减少回流的几个方法

- **合并多次**对DOM和`css`样式的修改。

- `display:none`：他所占据的空间会消失。`visibility:hidden`：元素只是不可见，但是仍然占空间。如果要改变一个元素可以用`visibility:hidden`，来避免回流

- DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。得益于浏览器的渲染队列机制

  >  当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。

- **文档碎片，批量修改DOM**：临时存放节点的容器，可以先把新创建的li放到容器中，然后一次性加载到页面中

  - `document.createDocumentFragment`

  - ```js
    // 文档碎片：临时创建的一个存放文档的容器，我们可以把新创建的LI，存放到容器中，当所有的LI都存储完，我们统一把容器中的内容增加到页面中（只触发一次回流）
    let frag = document.createDocumentFragment();
    for (let i = 1; i <= 5; i++) {
        let liBox = document.createElement('li');
        liBox.innerText = `我是第${i}个LI`;
        frag.appendChild(liBox);
    }
    item.appendChild(frag); 
    
    ```

- 动画效果应用到 position 属性为 **absolute** 或 **fixed** 的元素上（**脱离文档流**）

- CSS3硬件加速： **使用css3硬件加速，可以让transform：translate3d、opacity、filters这些动画不会引起回流重绘** 

- `display:none`：他所占据的空间会消失。`visibility:hidden`：元素只是不可见，但是仍然占空间。如果要改变一个元素可以用`visibility:hidden`，来避免回流

- 避免 table 布局和使用 `css` 的`javascript`表达式



​	



