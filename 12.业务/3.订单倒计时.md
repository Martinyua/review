

组件初始化(constructor)时计算一个偏移量：xTime = serverTime - Date.now()获取一个偏移量

然后通过startTime 和 持续时间 算出一个endTime

每次定时器运行的时候求一个已经走过的时间：hasPassTime = Date.now() - serverTime - xTime（消除误差）

倒计时的时间：time =  endTime - serverTime - hasPassTime（误差已清除）

组件卸载时清除定时器















js引擎是单线程的，主要分为主线程和事件队列，同步操作是在主线程上执行，而异步操作的函数会先放在事件队列当中，等到js主线程空闲了，才会去事件队列取出放到主线程执行。**定时器是属于异步事件，参数里面设置的时间，并不是延迟多少秒去执行回调函数，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行。**

如果按照上面的说法，假如同步代码耗时较长就会存在执行多次的问题，举个例子，假如设置一个 100ms 的定时器，定时器中代码需要执行1000ms，那么事件队列中就会添加10次定时器的函数（实际小于10次），这样1s之后会就执行10次代码，而不是我们想要的每隔 100ms 执行一次，**对此js引擎解决方法是，当使用setInterval时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。**

但是又会存在一个问题当下一个约定时间又到了，如果事件队列当中依然存在定时器的回调函数，这个时间点的定时器回调函数也不会放进事件队列…这样就会导致一些间隔被跳过了。



封装一个订单倒计时组件

在组件`didmount`后开启周期性计时器。

1. 先将订单创建时间加上`30min`得出到期时间，然后调用Date.parse()将他们全部转换为`ms`时间戳
2. 开启一个周期性计时器计算他们的时间差值，每秒调用一次。计算差值后调用一个函数判断差值是否小于零，小于零则清除定时器，并且执行父组件传入的方法（点击取消订单的方法）。
3. 如果大于零则将差值转换为标准格式显示
4. 注意页面退出后需要清除定时器

### 组件的功能

和普通倒计时不太一样。没有后端传输的不是到期时间，而是商户在管理端动态设置的多少分钟到期，所以多久到期不是一个固定的时间。所以需要自己计算出到期时间。然后再执行传入组件的函数

* **传入**开始时间，需要倒计时的时间，现在的时间（不传则为Date.now())，倒计时结束执行的函数
* 先用`getMinutes`，得到当前的分钟单位，再调用调用`setMinutes`加上30minutes。在调用get得到年，月，日，时，时分秒。拼接成统一的标准时间。然后转化为时间戳毫秒数。
* 然后利用这个`结束时间`**减去**`现在的时间转换的毫秒时间戳`得到一个ms差值。
* 然后通过这个差值取余数得到对应的分钟数和秒数。
* 最后组件卸载时记得清除定时器



### 倒计时的优化点

1. 倒计时的执行时间不是准时的。浏览器的所有js都是在单线程上执行的。如果遇到异步任务就会将这个任务挂起，当线程空闲时才会被调用。**定时器延迟是不能保证的**。假如订单页有大量要渲染的订单列表和定时器，或者用户点击取消订单，我觉得可能会导致执行同步任务用时太久，造成延时过长。
2. 最开始采用的是一**个周期性定时器`setInterval`**，每隔一秒进行一次。会出现上述问题
3. 优化策略：**在定时器开始前和运行时动态获取当前时间，计算误差**。**在组件constructor的时候获取一下当前时间，**不采用`setInterval`，采用`setTimeout`递归调用函数的形式来优化，在`setTimeout`执行的函数中获取`setTimeout`执行的时间，用**现在在定时器中获取的时间**减去开始在**constructor中定义的初始时间**再加上定时器执行的次数*1000来计算时间误差。然后再`setTimeout`中减去这个误差来使时间精确。可以performance.now()来获取更加精确的时间。而performance.now() 输出的是相对于 `performance.timing.navigationStart`(页面初始化) 的时间
4. 网络上的优化，重服务端获取当前的时间。
5. 确定无法消除第一个定时器的误差（单个定时器)

```
(runTime - (startTime + count * 1000));
```

```javascript
 var count = count2 = 0;
 var runTime,runTime2;
 var startTime,startTime2 = performance.now();//获取当前时间
 
 //普通任务-对比
 setInterval(function(){
     runTime2 = performance.now();
     ++count2;    
     console.log("普通任务",count2 + ' --- 延时：' + (runTime2 - (startTime2 + count2 * 1000)) + ' 毫秒');
 }, 1000);
 
 //动态计算时长
 function func(){
  runTime = performance.now();
     ++count;
     let time = (runTime - (startTime + count * 1000));
     console.log("优化任务",count2 + ' --- 延时：' + time +' 毫秒'); 
     //动态修正定时时间
     t = setTimeout(func,1000 - time);
 }
 startTime = performance.now();
 var t = setTimeout(func , 1000);
```

### 其他的方法

* 使用`webWorker`

  * Web Worker 的作用，就是**为 JavaScript 创造多线程环境**，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

  * 用法 `let worker = new Worker('worker.js');`

    ```js
     let worker = new Worker('worker.js');
       </script>
       </body>
       </html>
    
       // worker.js
       var count = 0;
       var runTime;
       var startTime = performance.now();
       setInterval(function(){
           runTime = performance.now();
           ++count;    
           console.log("worker任务",count + ' --- 延时：' + (runTime - (startTime + 1000))+' 毫秒');
           startTime = performance.now();
       }, 1000);
    
    ```

    https://www.jianshu.com/p/55b4eb04b1d3

    https://blog.csdn.net/qq_33988065/article/details/86692238

    https://juejin.cn/post/6844904083204079630#heading-11

    https://www.shymean.com/article/%E5%89%8D%E7%AB%AF%E6%97%B6%E9%97%B4%E6%A0%A1%E9%AA%8C%E4%B8%8E%E6%A0%A1%E5%87%86