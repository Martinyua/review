1. 通过taro.cennectSocket调用返回socketTask

   ```js
       Taro.connectSocket({
         url: 'ws://localhost:3000',
       }).then(task => {
         this.socketTask = task
         this.handleSocketOpen()
         this.handleSocketMessage()
         this.handleSocketClose()
         this.handleSocketError()
       })
   ```

2. handleSocketOpen()

   1. 建立socket连接
      1. 需要先获取用户信息，包括socketId（通过时间和math.radom生成的随机数）根据，userName，openid

      2. 通过socketTask.onOpen将上述通过send传输过去

         ```
           handleSocketOpen(): void {
             const { socketTask } = this
             const loginInfo: LoginInfo = {
               type: 'login',
               socketId: this.socketId,
               userName: this.userName,
               userAvatar: this.userAvatar,
               openid: this.openid
             }
             socketTask.onOpen(() => {
               socketTask.send({ data: JSON.stringify(loginInfo) })
               this.handleStartHeartCheck()
         
               /* 在成功登陆之后，重置重连标识 */
               this.isReconnected = false
             })
           }
         ```

         

3. handleSocketMessage()

   1. socketTask.onMessage()返回data，**先判断data是否为心跳检测返回**。如果不是，就从data中获取用户信息，是否是自己，发送信息。将收到的发送信息合并到消息列表
   2. 调用心跳检测机制

4. handleSocketClose

   1. 监听Onclose。将socketTask对象清空(设置为null)。

   2. 然后调用socketReconnect()

      ```js
        handleSocketClose(): void {
          const { socketTask } = this
          socketTask.onClose((msg) => {
            this.socketTask = null
            this.socketReconnect()
            console.log('onClose: ', msg)
          })
        }
      
      ```

      

5. handleSocketError

   1. 监听OnError。将socketTask对象清空(设置为null)。
   2. 然后调用socketReconnect()

6. socketReconnect()

   1. 设置三秒后重连，减去服务器压力

   2. 重连即重新调用SocketConnect()并且传入openid

      ```
        socketReconnect(): void {
          this.isReconnected = true
          this.reConnectTimer && clearTimeout(this.reConnectTimer)
      
          /* 3s延迟重连，减轻压力 */
          this.reConnectTimer = setTimeout(() => {
            this.socketConnect(this.openid)
          }, 3000)
        }
      ```

7. 心跳检测机制

   1. 为什么：  在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。

   2. 每隔一段指定的时间（计时器），向服务器发送一个数据，服务器收到数据后再发送给客户端，正常情况下客户端通过`onmessage`事件是能监听到服务器返回的数据的，说明请求正常。

   3. 如果再这个指定时间内，客户端没有收到服务器端返回的响应消息，就判定连接断开了，使用`websocket.close`关闭连接。

   4. 这个关闭连接的动作可以通过`onclose`事件监听到，因此在 onclose 事件内，我们可以调用`reconnect`事件进行重连操作。

   5. onOpen后调用一次，将心跳重置

   6. onMessage时调用一次，将心跳重置

   7. 若5s后没清除定时器，说明可能断链，调用close方法关闭socket。箭头socket关闭，调用重连

      ```
        handleStartHeartCheck(): void {
          const { socketTask } = this
          this.timeoutTimer && clearTimeout(this.timeoutTimer)
          this.heartCheckTimer && clearTimeout(this.heartCheckTimer)
          this.heartCheckTimer = setTimeout(() => {
            const checkInfo = {
              type: 'check',
              data: 'ping'
            }
            socketTask.send({ data: JSON.stringify(checkInfo) })
            this.timeoutTimer = setTimeout(() => {
              console.log('心跳检测超时了，断开连接')
              socketTask.close()
            }, 3000)
          }, 5000)
        }
      ```

      

![未命名文件(1).png](https://segmentfault.com/img/bVcNBBr)