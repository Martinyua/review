### `jscodeshift`

#### 为什么需要

>  `IDE` 的全局替换功能显然无法胜任这一工作；人工替换违背了程序员的 [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself) 原则，过程枯燥且有可能出错；写一个基于正则的替换脚本倒不是不可行，只是这样的脚本一般可维护性和可复用性都不太好，并且可能存在一些 bad case（如可能会匹配到注释或字符串字面量中的内容、需要考虑不同代码风格的情况）。



#### 概念

>  `jscodeshift` 是一个基于 `codemod` 理念的 `JavaScript/TypeScript` 重构工具，其原理是将 `JS/TS` 代码解析为抽象语法树（Abstract Syntax Tree，`AST`），并提供一系列用于访问和修改 `AST` 的 `API` 以实现自动化的代码重构。
>
> `jscodeshift` 将 babel parser、[ast-types](https://github.com/benjamn/ast-types)（用于快速创建新的 `AST` 节点）和 [recast](https://github.com/benjamn/recast/)（维护生成代码的代码风格信息）三大工具整合在一起，提供了简便快捷的操作接口；同时它还提供了多任务并行执行的功能，使其对于海量代码文件的重构操作可以并行运行，充分利用多核 CPU 算力，缩短重构任务执行时间。



#### 大致流程

```
- import Taro, { Component } from '@tarojs/taro';
+ import React, { Component } from 'react';
+ import Taro from '@tarojs/taro';
```

* 首先用到了一个AST的可视化工具
  * AST Explorer。可以看到解析代码获得的语法树并查看其中各个节点的**属性**
* 先分别找出从react导入和taro导入的包的语句
  * 先筛选出引入了"Taro"的代码文件先调用了find，传入type为`ImportDeclaration`。表示他为引入类型的语句。再用filter筛选出path.value.source.type **===** 'Literal' || 'StringLiteral' && value = '@tarojs/tarojs'‘
  * 传入type为`ImportDeclaration`。表示他为引入类型的语句。再用filter筛选出path.value.source.type **===** 'Literal' || 'StringLiteral' && value = 'react'‘
  * 我们取得了两个，一个TaroPath和reactPath。再在这条语句中找出type为`ImportSpecifier`的标识符，再在imported属性下找到使用forEach遍历，如果是react_api，就加入到`reactImportSpecifiers`，如果不是就加入到`TaroImportSpecifier`

