### 引入使用canvas组件

```
import
<Canvas/>
```



### 创建canvas上下文 CanvasContext

1. 参数一：和上下文的canvas组件的`canvas-id`属性
2. 参数二：当前自定义组件下的this，表示在这个自定义组件下查找拥有canvas-id的canvas



```
const ctx =  Taro.createCanvasContext(canvasId, component)
```

https://cloud.tencent.com/developer/article/1501018

https://segmentfault.com/a/1190000020189168

前置知识：canvas有两种height，width。

* 一个是**画布尺寸**，就是height,width属性。
* 一个是**画板尺寸**，就是通过css样式 里的height，width。默认为空
  * 如果没设置画板尺寸，画板尺寸会随画板尺寸改变
  * 如果都设置了，那么将不会不会随画布改变
  * 如果两者设置的尺寸不一样时，就会产生一个问题，渲染时**画布要通过缩放来使其与画板尺寸一样**，那么画布上已经绘制好的图形也会随之缩放，随之导致变形失真。
  * 保持画布尺寸和画板尺寸一致。

**高倍屏**canvas的问题

因为 `canvas` 不是矢量图，而是像图片一样是位图模式的。高 `dpi` 显示设备意味着每平方英寸有更多的像素。也就是说二倍屏，浏览器就会**以 2 个像素点的宽度来渲染一个像素**，该 `canvas` 在 **Retina** 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊

​	canvas绘制到高倍屏时，会以dpr平方个物理像素绘制渲染，因此会变得模糊

​	**解决**：**我们需要将画布尺寸设置为画板尺寸的dpr倍**

```
canvas.width=canvas. clientWidth*window.devicePixelRatio;
canvas.height=canvas.clientHeight*window.devicePixelRatio;
```

​	**绘制时，需要对ctx先使用scale()缩放后再绘制**

```
context.scale(window.devicePixelRatio,window.devicePixelRatio)；
```





### 定义一个图片转换为base64编码的方法。

> 为什么要多此一举将图片转换成`base64`编码呢，因为`canvas`导出图片的方法`toDataURL()`的方法，如果我们图片是存在**跨域**问题，他会导出失败，会报错。
>
> 网上有另一种方法，通过设置图片对象的`corssOrigin`的方法来实现跨域。但是这个方法有时候可以，有时候仍然会报错。还是获取`base64`编码保险点。

封装一个方法。核心是利用xhr.reponseType将返回数据类型改为blob类。然后利用fileReader对象的readAsDataUrl()传入blob，就可以将图片转换为base64。监听fileReader的onload事件就可以拿到这个base64编码

### 开始绘制



1. 定义一个图片转base64的方法

2. 通过getImageInfo获取图片宽高

3. 设置canvas的宽度为设备宽度减去40px，然后根据图片的宽高比例来设置画布的宽高比例

4. **适配高倍屏**。dpr绘制到高倍屏时，会以dpr平方个物理像素绘制，因此会变得模糊。比如在 **Retina** 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊。所以要将canvas放大到设备像素比来绘制。**我们要将画布尺寸设置为画板尺寸的两倍**，然后根据dpr对ctx使用scale(dpr,dpr)缩放

   

5. 使用drawImage绘制海报图片，传入五个参数，drawImage()，第一个是通过download方法的到的文件路径，第二，三个是开始绘制的起始坐标。第四五个是绘制图片的宽高

   ```
     this.ctx.clearRect(0, 0, newCanvasWidth, newCanvasHeight)
     this.ctx.drawImage(this.backgroundImage, 0, 0, newCanvasWidth, newCanvasHeight)
   ```

   

6. 绘制二维码，将二维码居中，用canvas的高度（宽度）减去二维码的高度（宽度）除以二得到开始绘制的起始位置，然后开始绘制二维码。

7. 保存图片。调用用户保存图片权限。调用`canvasToTempFilePath`，传入`canvasid`，还需要再调用`saveImageToPhotosAlbum`。

8. 一个坑，在Taro小程序里面。需将`Taro.createCanvasContext('shareCanvas',this)`替换`Taro.createCanvasContext('shareCanvas',this.$scope)`。在 Taro 的页面和组件类中，`this` 指向的是 Taro 页面或组件的实例。 Taro 的页面和组件所对应的小程序原生页面和组件的实例，这个时候我们可以通过 `this.$scope` 就能访问到它们。Taro的canvas对小程序的原生的canvas组件做了二次封装，所以说

### 遇到的问题

1. canvas图片toDataUrl()跨域问题
2. 高倍屏适配问题
3. 一个坑，在Taro小程序里面。需将`Taro.createCanvasContext('shareCanvas',this)`替换`Taro.createCanvasContext('shareCanvas',this.$scope)`。在 Taro 的页面和组件类中，`this` 指向的是 Taro 页面或组件的实例。 Taro 的页面和组件所对应的小程序原生页面和组件的实例，这个时候我们可以通过 `this.$scope` 就能访问到它们。
4. canvas 的宽高是根据图片的宽高来确定的，所以一开始就渲染canvas就会直接报错。所以需要设置一个变量，当图片请求完成后再进行渲染canvas渲染

https://segmentfault.com/a/1190000019299888