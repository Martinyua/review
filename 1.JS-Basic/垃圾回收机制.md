### 栈中

执行函数时，会有一个记录当前执行状态的指针（ESP），当一个函数执行结束后，JavaScript引擎通过下移ESP来销毁改函数保存在栈中的执行上下文

### 堆中

#### 垃圾回收策略：

代际假说和分带回收

**代际假说：**

* 一般的对象在内存中存在的时间很短。简单来说很多对象一经分配空间，就会很快被回收。
* 不死的对象，会活的更久。

​	V8会把堆分为**新生代**和**老生代**两个区域 ，新生代中存放生存时间短的对象，老生代中存放生存时间久的对象。

#### 工作流程

不管是新生代垃圾回收器还是老生代垃圾回收器，他们都有一套共同的执行流程

1. 标记活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 做内存整理。处理不连续的内存—内存碎片



#### 新生代回收器

这个区域不大，但是垃圾回收比较频繁。**一般是用Scavenge算法处理。**

​	具体流程：当对象区快被写满，执行一次垃圾清理操作。空闲区域**复制**对象区域并且执行**内存整理**，这样把这些就把存活的对象复制到空闲区域，同时还有序的排列了起来。然后进行角色反转操作。原来的对象区域变成了空闲区域。这种角色反转操作还能让新生代这两块区域无限重复使用下去。为了执行效率，一般新生代的空间会被设置的比较小。

并且采用对**象晋升策略**，**两次垃圾回收依然还活着，就移动到老生区**

​	

#### 老生代垃圾回收器：

特点：对象占用空间大，对象存活时间长（来自新生区的）。**一般采用标记-清除（Mark-Sweep）算法进行垃圾回收。**

​	标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

​	流程：首先是**标记**，**若调用栈中没有对这个对象的引用，则判断为垃圾数据。若有地址引用，则为活动对象，然后清除垃圾数据**。为了保证内存的连续性清除内存碎片，还需要**标记-整理算法。**

![lj](C:\Users\Lenovo\Desktop\Spring recruit review\1.JS-Basic\assets\lj.png)



**全停顿**：不过由于JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的
JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停
顿（Stop-The-World） 

**增量标记算法**：为了降低老生代回收垃圾造成的卡顿，将标记过程分为一个子标记过程，让垃圾回收标记和JS逻辑交替执行使用增量标记算法，使用增量标记算法可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果