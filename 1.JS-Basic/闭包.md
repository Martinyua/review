# 闭包

> 闭包就是能够读取其他函数内部变量的函数。定义在一个函数内部的函数由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。 ——阮一峰
>
> 闭包是函数和声明该函数的词法环境的组合。 ——MDN

- 一句话总结：闭包就是是由**函数**以及该函数创建时的**词法环境**组合而成的。这个环境包含了函数**创建时**能访问的所有局部变量

- 函数内部读取变量首先在自身词法环境中查找它的声明，如果没有找到会向父级词法环境中查找。一旦读取了父级词法环境中的变量就会造成一个闭包。

- 自由变量的查找是在**函数定义（创建）的地方**，向上级作用域寻找，而不是在执行的地方

  - 静态（词法）作用域：函数的作用域在函数定义的时候就己经决定了
  - 动态作用域：函数的作用域在函数执行的时候才决定

- 闭包的产生原因：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。从这里可以看出**闭包与环境有关**，而与环境扯上关系就离不开作用域，然而JS作用域中特殊的就是**词法作用域**，这个词法作用域又称之为静态作用域或者闭包。

- 闭包的形成条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数

- 闭包是否会内存泄漏？不会。`js`解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.

- 闭包的**用途**：闭包可以用在许多地方。它的最大用处有两个

  - 一个是前面提到的可以读取**函数内部的变量**。

  - 另一个就是让这些变量的值**始终保持**在**内存**中。

  - **隐藏数据，模拟私有变量和私有方法**

    ```js
    function createCache(){
        const data = {}
      return {
          set:funtion(key,val){
              data[key] = val
          }
          get:funtion(key){
              return data[key]
          }
      }
    }
    ```

- 闭包经典问题：我总感觉其实是异步才是重点，切入点应该是异步，不知道后面会不会有新的理解。写下自己的理解

  - 使用立即运行函数，将i通过参数传递，拷贝一份到外部函数作用域，相当于利用函数产生了一个块级作用域
  - 使用es6在块级作用域有效的let声明变量
  - 闭包其实就是函数和函数的词法作用域（定义时的作用域），不要想得太复杂

  ```js
  for(var i = 0;i<5;i++){
      (function(i){
        setTimeout(()=>{
          console.log(i)
        },1000*i)
      })(i)
      console.log(5)
  }
  
  ```

> 　　function f1(){
>
> 　　　　var n=999;
>
> 　　　　nAdd=function(){n+=1}
>
> 　　　　function f2(){
> 　　　　　　alert(n);
> 　　　　}
>
> 　　　　return f2;
>
> 　　}
>
> 　　var result=f1();
>
> 　　result(); // 999
>
> 　　nAdd();
>
> 　　result(); // 1000

在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

- 闭包两种表现形式：

  - **函数作为返回值**

    ```js
    function create(){
        let a = 100
        return funtion(){
            console.log(a)
        }
    }
    
    let fun = create()
    let a = 200
    fun() //100
    ```

  - **函数作为参数传递**

    ```js
    function print(fn){
        const a = 200
        fn()
    }
    const a = 100
    function fn(){
        console.log(a)
    }
    print(fn)  //100
    ```

- 解决闭包内存泄漏：在退出函数之前，将不使用的局部变量全部删除。将闭包内部的变量设置为null， 让变量失去引用，会被系统自动回收。

