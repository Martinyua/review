# 执行上下文

#### 执行上下文

执行上下文是评估和**执行 JavaScript 代码的环境**的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

#### 执行上下文的类型

JavaScript 中有三种执行上下文类型

- **全局执行上下文** — **这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。**它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
- **函数执行上下文** — **每当一个函数被调用时, 都会为该函数创建一个新的上下文。**每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
- **Eval 函数执行上下文** — 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 `eval`，所以在这里我不会讨论它。

#### ES3执行上下文内容

执行上下文是一个抽象的概念，我们可以将它理解为一个 `object` ，一个执行上下文里包括以下内容：

1. 变量对象 VO
2. 活动对象 AO
3. 作用域链
4. 调用者信息 this

* **变量对象（VO)**
  * 每个执行环境文都有一个表示变量的对象——**变量对象**，全局执行环境的变量对象始终存在，而函数这样局部环境的变量，只会在函数执行的过程中存在，在函数被调用时且在具体的函数代码运行之前，JS 引擎会用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。
  * 区别：**全局上下文中的变量对象就是全局对象，**以浏览器环境来说，就是 window 对象。**函数执行上下文中的变量对象内部定义的属性，是不能被直接访问的**，只有当函数被调用时，变量对象（VO）被激活为活动对象（AO）时，我们才能访问到其中的属性和方法。
* **活动对象（AO）**
  * 函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。

#### ES3中执行上下文生命周期

* **创建阶段**
  * **全局执行上下文**：执行全局代码前,创建一个全局执行上下文。对全局数据进行预处理。这一阶段会进行变量和函数的初始化声明，并且确定this的指向
  * **函数执行上下文：**在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象。对局部数据进行预处理
* **执行阶段：**
  * 执行阶段中，JS 代码开始逐条执行，在这个阶段，JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出
* 销毁阶段：
  * 一般来说当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权重新交给执行栈的上一层执行上下文（闭包有所不同）

#### ES5的执行上下文

`ES5` 规范又对 `ES3` 中执行上下文的部分概念做了调整，最主要的调整，就是去除了 `ES3` 中变量对象和活动对象，以 **词法环境（** **LexicalEnvironment component）** 和 **变量环境（** **VariableEnvironment component）** 替代。所以 `ES5` 的执行上下文概念上表示大概如下：

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

* **ThisBinding**（this指向）
  * 全局执行上下文中，this指向全局对象。
  * 函数执行上下文中，this的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、`new`绑定、箭头函数
* **词法环境**：由两个组成部分
  * **环境记录**：储存**变量和函数声明**
  * **对外部环境的引用**：可以访问器外部词法环境（outer）
* 词法环境的两种类型：全局环境和函数环境
  * 全局环境：没有外部环境（null），拥有全局对象关联的方法和属性，以及自定义的全局变量
  * 函数环境：用户在函数中定义的变量都被存储在环境记录中，包含了arguments对象。outer可以是全局环境，或者外部函数
* **变量环境**
  * 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。主要区别在于**词法环境用于存储函数声明和变量绑定（let和const）。变量环境仅仅存储变量绑定（var）**

# 作用域与作用域链

* **作用域** 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 **作用域链**。
* 和执行上下文的区别。执行上下文包括this、变量环境组件和词法环境组件。作用域只关心变量

# 闭包

> 闭包就是能够读取其他函数内部变量的函数。定义在一个函数内部的函数由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。 ——阮一峰
>
> 闭包是函数和声明该函数的词法环境的组合。 ——MDN

- 一句话总结：闭包就是是由**函数**以及该函数创建时的**词法环境**组合而成的。这个环境包含了函数**创建时**能访问的所有局部变量

- 函数内部读取变量首先在自身词法环境中查找它的声明，如果没有找到会向父级词法环境中查找。一旦读取了父级词法环境中的变量就会造成一个闭包。

- 自由变量的查找是在**函数定义（创建）的地方**，向上级作用域寻找，而不是在执行的地方

  - 静态（词法）作用域：函数的作用域在函数定义的时候就己经决定了
  - 动态作用域：函数的作用域在函数执行的时候才决定

- 闭包的产生原因：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。从这里可以看出**闭包与环境有关**，而与环境扯上关系就离不开作用域，然而JS作用域中特殊的就是**词法作用域**，这个词法作用域又称之为静态作用域或者闭包。

- 闭包的形成条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数

- 闭包的**用途**：闭包可以用在许多地方。它的最大用处有两个

  - 一个是前面提到的可以读取**函数内部的变量**。

  - 另一个就是让这些变量的值**始终保持**在**内存**中。

  - **隐藏数据，模拟私有变量和私有方法**

    ```js
    function createCache(){
        const data = {}
      return {
          set:funtion(key,val){
              data[key] = val
          }
          get:funtion(key){
              return data[key]
          }
      }
    }
    ```

- 闭包经典问题：我总感觉其实是异步才是重点，切入点应该是异步，不知道后面会不会有新的理解。写下自己的理解

  - 使用立即运行函数，将i通过参数传递，拷贝一份到外部函数作用域，相当于利用函数产生了一个块级作用域
  - 使用es6在块级作用域有效的let声明变量
  - 闭包其实就是函数和函数的词法作用域（定义时的作用域），不要想得太复杂

  ```js
  for(var i = 0;i<5;i++){
      (function(i){
        setTimeout(()=>{
          console.log(i)
        },1000*i)
      })(i)
      console.log(5)
  }
  
  ```

  

- 闭包两种表现形式：

  - **函数作为返回值**

    ```js
    function create(){
        let a = 100
        return funtion(){
            console.log(a)
        }
    }
    
    let fun = create()
    let a = 200
    fun() //100
    ```

  - **函数作为参数传递**

    ```js
    function print(fn){
        const a = 200
        fn()
    }
    const a = 100
    function fn(){
        console.log(a)
    }
    print(fn)  //100
    ```

- 解决闭包内存泄漏：在退出函数之前，将不使用的局部变量全部删除。将闭包内部的变量设置为null， 让变量失去引用，会被系统自动回收。

