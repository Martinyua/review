### var let const 区别

#### 变量提升

1. var声明变量存在**变量提升**，let和const不存在变量提升（实际上是存在的。我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于**暂时死区的限制**，你不能在 let x 之前使用 let）

   ```js
   console.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值
   var a = 100;
   
   console.log(b); //Uncaught ReferenceError：b is not defined  ===> 找不到b这个变量
   let b = 10;
   ```

#### 块级作用域

2. let 和 const声明形成**块级作用域**

```js
if(1){
    var a = 100;
    let b = 10;
}

console.log(a); // 100
console.log(b)  // 报错：b is not defined  ===> 找不到b这个变量
```

#### 不可重复声明

3. 同一作用域下let和const**不能声明同名变量**，而var可以

#### 暂时性死区

4. **暂时性死区**：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，**只有等到声明变量的那一行代码出现，才可以获取和使用该变量**

   ```js
   var tmp = 123; // 声明
   if (true) {
     tmp = 'abc'; // 报错 因为本区域有tmp声明变量
     let tmp; // 绑定if这个块级的作用域 不能出现tmp变量
   }
   
   ```

   为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

#### 不挂在到全局对象下

5. let、const声明的全局变量**不会挂在顶层对象下面**

#### const注意点

1. **一旦声明，必须马上赋值**

```
let p; var p1; // 不报错
const p3 = '马上赋值'
const p3; // 报错 没有赋值
```

2. const一旦声明就不能改变
   - 基本类型：不能改动
   - 复杂类型：变量指针不能改变

#### let、const使用场景:

1. `let`使用场景：变量，用以替代`var`。
2. `const`使用场景：常量、声明匿名函数、箭头函数的时候。

var和let的区别，面试老生常谈的问题，大多数人回答可能就是作用域和变量提升这两点不同，少有人能够知道内在原理，这样的回答面试官会满意吗？（手动滑稽）

我们就从声明过程，内存分配，和变量提升这三点来看这三者之间的区别。

一.声明过程
var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来
function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行
const、class都是同let一样的道理
比如解析如下代码步骤：

{
// 没用的第一行
// 没用的第二行
console.log(a) // 如果此时访问a报错 a is not defined
let a = 1
}
步骤：

发现作用域有let a，先注册个a，仅仅注册
没用的第一行
没用的第二行
a is not defined，暂时性死区的表现
假设前面那行不报错，a初始化为undefined
a赋值为1
对比于var，let、const只是解耦了声明和初始化的过程，var是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明。

二.内存分配
var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

三.变量提升
let const 和var三者其实会存在变量提升

let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。
var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined
function 的创建、初始化、赋值都被提升了