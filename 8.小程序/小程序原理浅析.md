### 双线程模型

小程序的渲染层和逻辑层分别由两个线程管理：**渲染层**的界面使用 **WebView** 进行渲染；**逻辑层**采用 **JSCore** 运行 JavaScript 代码。一个小程序存在多个界面，所以渲染层存在**多个 WebView**。这两个线程间的通信经由小程序 **Native** 侧中转，逻辑层发送网络请求也经由 Native 侧转发，小程序的通信模型下图所示。

每个小程序页面都是用不同的 WebView 去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个 WebView 的任务过于繁重。

**为什么要这么设计呢？**

> 为了**管控和安全**，微信小程序**阻止**开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。将逻辑层与视图层进行分离，视图层和逻辑层之间只有数据的通信，可以防止开发者随意操作界面，更好的保证了用户数据安全。

![img](https://image.fundebug.com/2019-05-16-003.jpeg)

- **逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等**
- **视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程**
- **JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验**

### 为什么安全

因为Web技术是非常开放的，JavaScript可以做任何事。但在小程序这个场景下，它不会给开发者那么高的权限：

- 不允许开发者把页面跳转到其他在线网页
- 不允许开发者直接访问DOM
- 不允许开发者随意使用window上的某些未知的可能有危险的API

### 如何通信？

逻辑层和视图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

**这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。**

**1. 在渲染层把 WXML 转化成对应的 JS 对象，Js对象会模拟DOM树**

**2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。**

**3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。**

我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。

### 运行机制

#### 启动

- 热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；
- 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。

#### 销毁

只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。

#### 更新机制

开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。

小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

所以如果想让用户使用最新版本的小程序，可以利用 `wx.getUpdateManager` 做个检查更新的功能