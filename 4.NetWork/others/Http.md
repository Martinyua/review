# Http

HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。HTTP 1.1通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。如，HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP/1.0不支持文件断点续传，<code>RANGE:bytes</code>是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。<code>RANGE:bytes=XXXX</code>表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！

由上，HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：

1 缓存处理

2 带宽优化及网络连接的使用

3 错误通知的管理

4 消息在网络中的发送

5 互联网地址的维护

6 安全性及完整性

## 一次完整的HTTP请求所经历的7个步骤

> 一次完整的HTTP请求所经历的7个步骤

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤： 

- 建立TCP连接

TCP与UDP  传输层   HTTP/FTP 应用层

比如TCP，是用于发送大量数据的，我发出去一万个包，另一台电脑就需要告诉我是否接收到一万个包，如果缺少3个包，就告诉我是第1001/234/8888个包丢了，那我再发一次。这样，就能保证对方把这个视频完整接收了。



例如UDP，适用于发送少量数据的。我发20个包出去，一般不会丢包，所以 ，我不管你收到多少，在多人互动游戏中，也经常受到UDP协议，因为一般都是简单的额信息，而且有广播的需求。如果用TCP，效率就会很低，因为它会不停地告诉主机我收到20个包，或者18个包，再发我两个！如果同时有1万台计算机都这样做，那么用TCP反而会降低效率，还不如用UDP，主机发出去就算了，丢几个包就卡一下，算了，下次再发包更新。



TCP协议是会绑定IP和端口的协议，下面会介绍IP协议。

在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。**HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。**

- Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

- Web浏览器发送请求头
  - 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。
- Web服务器应答
  - 客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**
- Web服务器发送应答头
  - 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
- Web服务器向浏览器发送数据
  - Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。
- Web服务器关闭TCP连接
  - 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

```
Connection:keep-alive
```

TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接





http应用层与tcp传输层简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。



http建立在tcp协议之上，户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。



 TCP是底层通讯协议，定义的是数据传输和连接方式的规范
   HTTP是应用层协议，定义的是传输数据的内容的规范
   HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP 



 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导 致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

   而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

   很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。



在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。

在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接  Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。虽然这里使用TCP连接保持了一段时间，但是这个时间是有限范围的，到了时间点依然是会关闭的，所以我们还把其看做是每次连接完成后就会关闭。后来，通过Session, Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。



Http不是建立在TCP的基础上吗，为什么还能是短连接？现在明白了，Http就是在每次请求完成后就把TCP连接关了，所以是短连接。而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着。



Socket是TCP/IP对外提供的编程接口，Socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，Socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。



通常的短连接操作步骤是： 
连接→数据传输→关闭连接；

而长连接通常就是： 
连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；



输入url到页面呈现过程

浏览器需要的是IP地址，于是会去浏览器缓存、系统缓存（hosts文件）、路由器缓存（映射表）中查询，如果没有，会将域名发送到本地DNS服务器，如果也找不到就会发给其他服务器进行递归，根域名，返回顶级域名服务器的IP地址，然请求顶级域名服务器返回二级域名服务器IP，...，直到找到对应的IP地址返回给浏览器。



浏览器得到IP地址，此时作用于传输层的TCP协议会向远端服务器发起连接请求，进行三次握手

①源端->远端：你好，我想跟你连接可以吗？（SYN=1,seq=x）

②远端->源端：可以，你确定要连接是吧？（SYN=1,ACK=1,seq=y,ack=x+1）

③源端->远端：确定，我们连接吧！（ACK=1,seq=x+1,ack=y+1）



 建立起一个TCP连接需要经过“三次握手”：

   第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

   第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

   第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。



连接上后，将用户输入的地址、IP地址封装成HTTP Request请求报文给服务器，服务器收到请求后会发出应答响应数据

请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号；

request header：

   包括了，1.请求的方法是POST/GET,请求的URL，http协议版本2.请求的数据，和编码方式3是否有cookie和cooies，是否缓存等。

   post和get请求方式的区别是，get把请求内容放在URL后面，但是URL长度有限制。而post是以表单的形势，适合要输入密码之类的，因为不在URL中显示，所以比较安全。

request body：

即请求的内容.

![](https://img-blog.csdn.net/20180503171354728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpZHVkaWR1ZHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。

![](https://img-blog.csdn.net/20180503171549770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpZHVkaWR1ZHU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

断开TCP连接，四次挥手

①源端->远端：好了，咱们断开吧（FIN=1,seq=u）

②远端->源端：行，等我稍微检查一下还有没有要发你的数据（ACK=1,seq=v,ack=u+1）

③远端->源端：可以了，咱们断开吧，拜拜（FIN=1,ACK=1,seq=w,ack=u+1）

④源端->远端：好的，再会，拜拜（ACK=1,seq=u+1,ack=w+1）



OSI七层模型





阅读 图解HTTP

---

T/I协议族按层次分为

应用层, ftp dns http

传输层，tcp

网络层

接口/链路层

发送端从应用层到链路层，两个链路层之间进行连接（接口层）

传输层把收到的数据（http请求报文）进行分割，在各个报文上打上标记序号及端口号转发给网络层

在网络层ip协议，增加作为通信目的地的MAC地址（物理地址/硬件地址，定义网络设备位置）后转发给链路层，



发送端在层与层之间传输时，每经过一层会打上一个该层所属的首部消息，在接收端一层层消去。如TCP首部（TCP报文段），IP首部IP数据包，以太网首部 网络架构等



IP协议（网络层），≠IP，IP协议的作用是把各种数据包传送给对方，如果想要保证确实送达，需要各种条件，IP地址和MAC地址，前者指明了节点被分配到的地址，MAC地址是网卡所属的固定地址，几乎不会变。IP地址可以搜索对方的地址，一边中转一边传送



为了确保准备无误的送达，会采用三次握手，先发送一个带有SYN标志的数据包，收到后回以一个带有SYN/ACK标志的数据包来传达确认信息，发送端再回传一个带有ACK标志的数据包。如果中断会重新开始。TCP协议会分割HTTP报文，按序号分为多个报文段，另一边的TCP协议会将它组装起来。



DNS协议，提供域名到IP的解析服务，www.linbudu.top，www服务器名，linbudu.top域名，整个称为网站名/主机名，加上网页传输协议就是URL，DNS （Domain Name System），域名系统，万维网上作为 **IP地址** 与 **域名** 互相映射的一个分布式数据库， 可提供域名（**主机域名**）解析服务，使得人们可以不用记录 IP 数字串而访问站点。 通过域名得到 IP 地址的过程被称为 域名解析（主机域名解析）。



URI与URL，URI是由某个协议方案表示的资源的定位标识符，协议方案指访问资源所使用的协议类型名称。

绝对

如`http://user:pwd@www.example.com:8080/dir/file?uid=1#hash`

协议 认证 服务器地址 端口号 文件路径 查询字符串  片段标识符 



http是无状态协议，不会做持久化处理，但引入了cookie就可以管理状态了



客户端请求访问资源而发送请求，URI需要将作为请求报文中的请求URI包含在内，可以是完整的绝对URI，也可以是/index.html这样的

如下是查询HTTP服务器端支持的HTTP方法种类

OPTIONS * HTTP/1.1



不同的HTTP方法



GET 带上If-Modified-Since，仅返回其值以后更新过的URI资源，如果未更新则返回304



POST 传输实体的主体 content-length



PUT 传输文件 保存到请求URI指定的位置，204：该位置已有此文件存在



HEAD 同GET，但是不返回报文主体部分，只返回响应首部，用于确认URI有效性、资源更新日期等



DELETE 删除文件 按请求URI删除指定资源



OPTIONS 返回服务器支持的方法 Allow



TRACE CONNECT



持久连接keep-alive，只要任意一端没有明确提出断开连接就维持连接状态



cookie！session！

cookie会根据响应中的set-cookie字段保存，下次再往该服务器发送请求时会自动带上cookie



HTTP报文，用于HTTP协议交互的信息，分为请求报文和响应报文，本身是由CR+LF作换行符的数据构成的字符串文本，大致分为首部和主体，主体不是必须的，由首个空行（CR+LF）分隔

首部：请求/响应行  请求/响应通用字段 



内容协商:

 Accept

 Accept-Charset Accept-Encoding 

Accept-Language

 Content-Language



状态码

1- 信息性状态码 正在处理

2- 成功状态码 正常处理完毕

200 

204 没有也不允许包含任何实体的主体，客户端不会更新网页

206 只想要一部分资源

3- 重定向状态码 需要附加操作才能完成请求 

301 永久重定向，资源已被分配了新的URI，重新保存书签等

302 临时性重定向，希望本次能使用新的URI访问

303 See Other 由于请求对应的资源存在另一个URI，希望客户端使用GET方法定向获取请求资源，

上面的三个状态码返回时，几乎所有的浏览器都把POST改成GET，并删除请求报文内的主体，之后会自动再次发送请求

304 客户端发送附带条件的请求，如if-match if-modified-since if-none-match if-range if-unmodified-since ，并且没有符合条件的请求。客户端缓存未过期。与重定向无关哈

4- 客户端错误状态码 无法处理请求

400 语法错误 浏览器会像对待200一样

401 需要有通过HTTP认证的信息 如果有说明认证失败

403 禁止访问

404

5- 服务端错误状态码 处理出错

500 内部故障

503 繁忙/停机维护



缓存服务器，避免多次向源服务器转发资源，就 近 获 取




