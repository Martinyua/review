

当客户端收到服务端的SYN+ACK应答后，其状态变为ESTABLISHED，并会发送ACK包给服务端，准备发送数据了。如果此时ACK在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK包，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。



当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。



### 加性增、乘性减（additive-increase multiplicative-decrease，AIMD）\

 ***\*TCP拥塞控制的思想：当出现丢包事件时，让发送方降低其发送速率（通过减小拥塞窗口cwnd的大小）。\****

TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。

传输协议主要有UDP（无连接的协议、不可靠）和TCP（有连接、可靠）两种

TCP可靠主要表现在：

- 接收方会对接收到的数据进行确认
- 发送方会重传接收方未确认的数据
- 接收方会对接收到的数据按照正确的顺序进行重新排列，并删除重复的数据
- 提供了控制拥挤的机制

![img](https://user-gold-cdn.xitu.io/2019/6/24/16b89c7659d66bee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 三次握手：

  - 第一次握手：主机A发往主机B，主机A初始序号是X，设置SYN（同步）位，未设置ACK（确认）位
  - 第二次握手：主机B发往主机A，主机B初始序号是Y，ACK（确认号）是X+1，X+1暗示已经收到主机A发来主机B的同步序号。设置ACK位和SYN位
  - 第三次握手：主机A发往主机B，主机A初始序号是X+1，ACK是Y+1，Y+1暗示已经收到主机A发来主机B的同步序号。设置ACK位，未设置SYN位。

  三次握手解决的不仅仅有序号问题，还解决了包括窗口大小、MTU(Maximum Transmission Unit,最大传输单元)，以及所期望的网络延时等其他问题。

- 构建TCP请求会增加大量的网络时延，常用的优化方式如下所示

  - 资源打包，合并请求
  - 多使用缓存，减少网络传输
  - 使用keep-alive建立持久连接
  - 使用多个域名，增加浏览器的资源并发加载数，或者使用HTTP2的管道化连接的多路复用技术

网络层使用IP协议来选择路线

数据链路层实现网络相邻节点间的可靠的数据通信

物理层传输数据



## 为什么是三次握手？ 

### 什么是三次握手

学过网络编程的人，应该都知道TCP建立连接的三次握手，下面简单描述一下这个过程。 
![这里写图片描述](https://img-blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> **如图所示** 
> **第一次握手**：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。 
> **第二次握手**：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。 
> **第三次握手**：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。

### 为什么不是两次

我们先来将三次握手这个过程捋一遍。(S-服务端，C-客户端)

> 第一次握手后，S可以确认自己收报文与C发报文的功能都正常，而C呢，它什么都不能确认。 
> 第二次握手后，C可以确认自己的收发报文与S的收发报文功能都正常，也就是认为连接已建立。 
> 那么第三次呢，S也可以确认双方能够正常通信。

假想一下，如果我们去掉了第三次呢？ 
因为我们不进行第三次握手，所以在S对C的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果C并没有收到S的回应呢？此时，C仍认为连接未建立，S会对已建立的连接保存必要的资源，如果大量的这种情况，S会崩溃。 
**因此第三次握手是必要的。**

### 为什么不是四次

首先，如果乐于思考的同学应该会对上面有这样的疑问：

```
既然没法确认第二次的握手，C是否可以收到，
那么怎么确定第三次握手S就可以收到呢？
```

不错，这根本没法确定，因为完全可靠的通信协议是根本不存在的，我们任何的通信协议都是在接受这样的现实情况之上进行的。 
而三次握手后，C和S至少可以确认之前的通信情况，但无法确认之后的情况。 
在这个道理上说，无论是四次还是五次或是更多次都是徒劳的



TCP.UDP

为什么UDP-视频

1、连接方面区别

TCP面向连接（如打电话要先拨号建立连接）。

UDP是无连接的，即发送数据之前不需要建立连接。

2、安全方面的区别

TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。

UDP尽最大努力交付，即不保证可靠交付。

[![img](https://iknow-pic.cdn.bcebos.com/b17eca8065380cd784ddd18baf44ad3458828190?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)](https://iknow-pic.cdn.bcebos.com/b17eca8065380cd784ddd18baf44ad3458828190)

3、传输效率的区别

TCP传输效率相对较低。

UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。

4、连接对象数量的区别

TCP连接只能是点到点、一对一的。

UDP支持一对一，一对多，多对一和多对多的交互通信。

UDP 的主要应用场景

需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。
不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。
需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候
基于 UDP 的几个例子

直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议
实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响
物联网。



TCP 的包头有哪些内容，分别有什么用

首先，源端口和目标端口是不可少的。
接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到
确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题
状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更
窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。
通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：

顺序问题
丢包问题
连接维护
流量控制
拥塞控制
2.1 TCP 的三次握手
所有的问题，首先都要建立连接，所以首先是连接维护的问题

TCP 的建立连接称为三次握手，可以简单理解为下面这种情况

A：您好，我是 A
B：您好 A，我是 B
A：您好 B

至于为什么是三次握手我这里就不细讲了，可以看其他人的博客，总结的话就是通信双方全都有来有回

对于 A 来说它发出请求，并收到了 B 的响应，对于 B 来说它响应了 A 的请求，并且也接收到了响应。

TCP 的三次握手除了建立连接外，主要还是为了沟通 TCP 包的序号问题。

A 告诉 B，我发起的包的序号是从哪个号开始的，B 同样也告诉 A，B 发起的 包的序号是从哪个号开始的。

双方建立连接之后需要共同维护一个状态机，在建立连接的过程中，双方的状态变化时序图如下所示

这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了。

2.2 TCP 四次挥手
说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下

A：B 啊，我不想玩了
B：哦，你不想玩了啊，我知道了
这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。
B：A 啊，好吧，我也不玩了，拜拜
A：好的，拜拜

这样整个连接就关闭了，当然上面只是正常的状态，也有些非正常的状态（比如 A 说完不玩了，直接跑路，B 发起的结束得不到 A 的回答，不知道该怎么办或则 B 直接跑路 A 不知道该怎么办），TCP 协议专门设计了几个状态来处理这些非正常状态

断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态。

A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。

如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要等待一段时间，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要足够长。

2.3 累计确认
TCP 如何实现可靠传输?

首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。

为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分

发送并且确认的
发送尚未确认的
没有发送等待发送的
没有发送并且暂时不会发送的
这里的第三部分和第四部分就属于流量控制的内容



对于接收端来讲，它的缓存里面的内容要简单一些

接收并且确认过的
还没接收，但是马上就能接收的
还没接收，但也无法接收的
对应的数据结构如下



发送端和接收端当前的状态如下：

1、2、3 没有问题，双方达成了一致
4、5 接收方说 ACK 了，但是发送方还没收到
6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。
根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。

假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？

有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。

例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。

2.5 流量控制的问题
在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小

简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了



2.6 拥塞控制的问题
也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。

水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。

如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。



TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。

具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来

慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。

拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。



TCP 是面向连接的，UDP 是面向无连接的
UDP程序结构较简单
TCP 是面向字节流的，UDP 是基于数据报的
TCP 保证数据正确性，UDP 可能丢包
TCP 保证数据顺序，UDP 不保证
什么是面向连接，什么是面向无连接

在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会

TCP 为什么是可靠连接

通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。
TCP 报文头里面的序号能使 TCP 的数据按序到达
报文头里面的确认序号能保证不丢包，累计确认及超时重传机制
TCP 拥有流量控制及拥塞控制的机制
TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的
拥塞控制时通过拥塞窗口来解决的



### 1.2 几个基本概念

- 发送缓存：发送方将可以发送给接收方的数据暂时存储在发送缓存中
- 发送窗口：已发送未确认的数据+待发送的数据。**发送窗口时发送缓存的一部分**
- 接收缓存：存放发送方传输的未得到确认的数据以及未按序到达的数据
- 接收窗口**（通知窗口）**—rwnd：接收方能够接收数据的大小
- 拥塞窗口—cwnd：拥塞窗口反映的是当前网络的拥塞程度

# 2.TCP的流量控制

- 利用滑动窗口进行流量控制

### 2.1 流量控制原理

一般而言，发送窗口越大，传输数据速度越快，但是这很容易造成网络拥塞，因此需要动态的改变发送窗口大小，发送方发送窗口大小不应该大于接收方接收窗口的大小。流量控制的作用就是让发送方发送数据的速度不要太快，要让接收方来得及接收所有的数据。

### 2.2 发送窗口如何改变

接收端发送的确认报文中会将自己接收窗口的大小填入报文头部窗口大小的位置中，发送方接收到确认后，根据这个数据改变发送端窗口大小。若发送方的窗口大小为0，此时，接收端有收到报文，也就是说，此时接收窗口大小不再是0，发送端继续发送数据。
 考虑这样的问题

### 2.3 流量控制和拥塞控制的关系

流量控制是点对点的控制，是端到端的问题，旨在改变发送端发送窗口的大小，控制发送数据的速率，以使接收端能够来得及接受所有的数据。
 而拥塞控制是为了防止太多的数据传输在网络中，拥塞控制是一个全局性的控制，必须保证当前网络能够承受当前的数据负载。若发送方在一定时间内一直未接收到来自接收端的确认信息，就会认为网络出现拥塞，但并不知道产生拥塞的原因。

# 3.拥塞控制算法

- 慢开始和拥塞避免、快重传和快恢复

### 3.1慢开始算法和拥塞避免算法

- 慢开始算法
  慢开始首先设置cwnd=1,发送方每接收到来自接收方的确认报文就会将拥塞窗口增加1。每一次传输过程中，比如，发送发送4个报文段后，接收到来自接收方发送来的四个接收报文，将会对发送方拥塞窗口增加4，那么每一次传输轮回，慢开始的过程会将发送方的拥塞窗口增加1倍，即拥塞窗口呈指数级增长。
- 拥塞避免算法
  为防止拥塞窗口增长过大引起网络拥塞，设置一个满开始门限ssthresh，若当前拥塞窗口值大于满开始门限值时，减缓拥塞窗口增长速率，从指数级增长改为线性增长，每个传输轮次仅增长1，若网络出现拥塞（即发送方没有按时接收到来自接收方的确认报文），就将慢开始门限值设置为当前拥塞窗口大小的一半，同时令拥塞窗口大小为1。

### 3.2 AIMD算法

- “乘法减小”和“加法增大”（AIMD）算法
  拥塞避免阶段，每一个传输轮次，将拥塞窗口值加1，增长速率比较慢，但能够有效防止网络出现拥塞。若网络出现拥塞就将发送发慢开始门限值减半，若网络频繁出现拥塞，那么满开始门限值的下降速率很快，这将极大程度的减小发送方发送到网络中的数据

### 3.3 快重传和快恢复

- 快重传
  在接收方收到乱序的报文时，立即发出一个重复确认（即上一次有序的报文21），在接下来收到的报文中只要不是有序的报文21，都将立即重复发出一个确认报文，以通知发送方报文未按序到达。快重传规定，发送方若连续收到3个重复的报文，应立即重新发送对方未收到的数据，而不必等待超时重传时间的到达。
- 快恢复
  若发送方连续收到来自接收端的3个重复确认，可知道此时网络并没有发生拥塞，但是为了防止拥塞，执行“乘法减小”操作，将慢开始门限值减半，但**不执行慢开始操作**，即不将拥塞窗口大小设置为1，而是将拥塞窗口cwnd的值设置为ssthresh的一半，然后开始执行拥塞避免算法（“加法增大”）
  **采用快恢复算法时，慢开始算法只在建立连接和网络出现超时时使用**
