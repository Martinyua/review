## HTTP

HTTP协议（**超文本传输协议**）是建立在`TCP`连接的基础之上的，是一种允许浏览器向服务器获取资源的协议，他指定了客户端可能发送什么样的消息以及得到什么样的响应。

特点：

* 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
* 灵活：HTTP允许传输任意类型的数据对象。
* 无连接：无连接的含义是限制每次连接只处理一个请求。
* 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。

### HTTP报文结构

请求行 + 请求头 + 消息正文（实体）

1. 请求行：描述基本信息

   ```
   eg： GET/HTTP/1.1
   ```

2. 请求头：头部字段集合（header），使用key-value形式更详细的说明报文

   1. HOST：告诉服务器由哪个主机去处理
   2. Connection：Keep-Alive 长连接
   3. Content-Type
   4. User-Agent
   5. Date
   6. ...

3. 请求体：又称实体，或者body，消息正文



响应报文：

* 响应行
  * 版本号 :`HTTP/1.1`
  * 状态码 `200`
  * 原因字符串 `OK`
* 响应头
  * Server表示
  * Content-Type
  * Date
  * ...
* 响应体

### 状态码

状态码

* 1- 信息性状态码 正在处理

* 2- 成功状态码 正常处理完毕
  * 200 
  * 204 没有也不允许包含任何实体的主体，客户端不会更新网页
  * 206 只想要一部分资源

* 3- 重定向状态码 需要附加操作才能完成请求 
  * 301 **永久重定向**，资源已被分配了新的URI，重新保存书签等,在location中给出目标url
  * 302 **临时性重定向**，希望本次能使用新的URI访问
  * 303 See Other 由于请求对应的资源存在另一个URI，希望客户端使用GET方法定向获取请求资源，上面的三个状态码返回时，几乎所有的浏览器都把POST改成GET，并删除请求报文内的主体，之后会自动再次发送请求
  * **304 客户端发送附带条件的请求**，如if-match if-modified-since if-none-match if-range if-unmodified-since ，并且没有符合条件的请求。客户端缓存未过期。与重定向无关哈

* 4- 客户端错误状态码 无法处理请求
  *  400 语法错误 浏览器会像对待200一样
  * 401 需要有通过HTTP认证的信息 如果有说明认证失败
  * 403 禁止访问
  * 404 服务器无法根据客户端的请求找到资源

* 5- 服务端错误状态码 处理出错
  * 500 内部故障
  * 503 繁忙/停机维护

### 请求方法

#### 常用方法

* GET：从服务器获取资源
* HEAD：与GET类似，但是只传回响应头
* POST：向URL指定的资源提交数据（create）
* PUT：与POST类似。但PUT通常表示修改（update）



#### 非常用方法

* DELETE：删除资源
* CONNECT：表示服务器为客户端和另一台远程服务器建立连接
* OPTIONS：要求服务器列出可对该资源的操作方法。在Allow中返回
* TRACE：显示请求-响应的传输路径



### 请求流程

1. 构建请求
2. 查找缓存
3. DNS解析（准备IP和端口号）
4. 等待TCP队列
5. 简历TCP连接
6. 发送HTTP请求



## HTTP1.1

### 缓存处理

在 HTTP1.0 中主要使用 header 里的 `If-Modified-Since`（比较资源最后的更新时间是否一致）,`Expires`（资源的过期时间（取决于客户端本地时间）） 来做为缓存判断的标准。

HTTP1.1 则引入了更多的缓存控制策略：

- `Entity tag`：资源的匹配信息
- `If-Unmodified-Since`：比较资源最后的更新时间是否不一致
- `If-Match`：比较 `ETag` 是否一致
- `If-None-Match`：比较 `ETag` 是否不一致

### 长连接

HTTP1.0 需要使用`keep-alive`参数来告知服务器端要建立一个长连接，而 HTTP1.1 **默认支持长连接**，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

### HOST头处理

在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

### 宽带优化

支持断点续传

### 新增错误通知和请求方式

在 HTTP1.1 中新增了 24 个错误状态响应码

- PUT：请求服务器存储一个资源
- DELETE：请求服务器删除标识的资源
- OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求
- CONNECT：保留请求以供将来使用
- TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断



## HTTP2.0

HTTP1.X 版本的缺陷概括来说是：线程阻塞，在同一时间，同一域名的请求有一定的数量限制，超过限制数目的请求会被阻塞。

#### 二进制分帧

HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩**。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。 **HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用**二进制编码**。实现**方便且健壮**

#### 多路复用

多路复用允许同时通过单一的 HTTP2.0 连接发起多重的请求-响应消息。即是**连接共享**，提高了**连接的利用率，降低延迟**。即每一个 request 都是是用作连接共享机制的。

* 同域名下所有通信都在**单个连接**上完成。

- 单个连接可以承载任意数量的**双向数据流**。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

这一特性，使性能有了极大提升：

- 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。
- 并行交错地发送多个请求，请求之间互不影响。
- 并行交错地发送多个响应，响应之间互不干扰。

#### Header压缩

HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立**“字典”**，用**索引号表示重复的字符串**，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

### 服务器推送

这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。比如浏览器向服务器请求一个页面，之前需要等到浏览器收到页面解析`html`后，发现里面引用了静态资源，浏览器再向服务器发送静态资源的请求。但是现在服务器可以直接将页面和所需的静态资源一并返回。

## HTTP3

　QUIC并不使用TCP，而改用UDP (User Datagram Protocol)为底层，UDP虽然较不安全、可能有掉封包或封包后发先至的问题，但较简单、传输效率更高，能大幅减低延迟性。

1. 为什么需要`Quic`：
   近三十年来，`tcp`协议发展得非常缓慢
   很多网络中间层，比如防火墙、网关等，都强依赖于tcp指定的各类规则，所以tcp的修改很容易由于这些中间环节的存在而受到干扰。

2. `Quic` 相比现在广泛应用的 `tls`+`http`+`tcp` 协议有如下优势 ：
   减少了 TCP 三次握手及 TLS 握手时间。
   改进的拥塞控制。
   避免队头阻塞。

