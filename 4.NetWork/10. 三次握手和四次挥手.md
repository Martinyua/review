#### 三次握手

1. 序号：seq。
2. 确认序号：ack序号
3. 标志位：SYN，ACK

- 第一次，客户端向服务端发送连接请求报文段。该报文段的头部中`SYN=1，seq=x`。请求发送后，客户端便进入SYN-SENT状态。
- 第二次。服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：`SYN=1，ACK=1，seq=y，ack=x+1`。该应答发送完成后便进入SYN-RCVD状态。
- 第三次，客户端收到服务端的回复。于是知道服务端已经收到了序列号为x的那段报文，知道了服务端同意了这次连接。发送一个标志位`ACK=1，seq=x+1，ack=y+1`

![img](https://pic4.zhimg.com/80/v2-576b043d12353928eea6e45373655668_1440w.jpg?source=1940ef5c)



#### 为什么需要三次握手

1. 确认双发都有接受和发送的能力。

2. **本质：TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。`确认双方信息的初始序列号`**，也是需要自己知道了，对方已经知道了它的初始序列号。本质还是为了可靠传输所采取的措施。

3. **书上定义的是避免已经失效的连接请求报文段再次传输到服务端。**

   > 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。



#### 四次挥手

* 每一个方向都需要一个FIN和ACK

1. 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。

2. 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSED_WAIT` 状态。

   客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。

3. 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。

4. 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态

   服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。

   客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

![img](https://pic4.zhimg.com/80/v2-2085b747725cd09fb01334cd29774b6d_1440w.jpg?source=1940ef5c)

#### 	为什么是四次挥手

* 但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### 等待2MSL

* 报文段最大生存时间MSL
* **为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失**，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。**服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认**，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。



#### 参考

https://juejin.cn/post/6844903958624878606#heading-7

 nginx 

 npm run build