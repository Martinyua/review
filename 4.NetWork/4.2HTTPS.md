## HTTPS协议

其实也就是弥补了HTTP的缺点： 

* 数据**隐私性**，内容经过加密；

* （加解密） 数据**完整性**，内容经过完整性校验；

* （数字签名） **身份认证**，第三方无法伪装客户端/服务器的身份（数字证书）

#### HTTP与HTTPS的区别

HTTPS标准端口443，HTTP是80 HTTPS在浏览器上会显示绿色的安全锁，而HTTP没有 弥补了HTTP的缺点，数据的隐私性、完整性、身份验证。也就是更加安全。

HTTPS把下层的协议由TCP/IP换成了SSL/TLS

#### 混合加密机制(HTTPS采用的方式)

结合两种加密方式的优点，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式。**

流程：发送密文的一方使用"对方的公钥"进行加密处理"对称的密钥"，然后对方接收到之后使用自己的私钥进行解密得到"对称的密钥"，这就达到了确保交换的密钥是安全的前提下使用对称加密方式进行通信。

HTTP是明文传输，传输的每一个环节都可能会被第三方窃取或者篡改。具体来说就是HTTP数据经过TCP层，然后经过WIFI路由器、运营商和目标服务器，都可能被中间人拿到数据并进行篡改，这就是常说的**中间人攻击**

HTTPS是一个加强版的HTTP。采用**对称加密**和**非对称加密**结合的方式来保护浏览器和服务端之间的通信安全。 对称加密算法加密数据 + 非对称加密算法交换密钥 + 数字证书验证身份 = 安全

HTTPS由两部分组成：HTTP + SSL/TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据是加密后的数据

## 加密过程

首先浏览器会给服务器发送一个`client_random`和一个加密的方法列表

服务器接受后给浏览器返回另一个随机数`server_random`和加密方法

现在两者拥有三种相同的凭证: `client_random`, `server_random`和`加密方法`

接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务器通信的`暗号`了

![SSL : TLS 握手过程](https://segmentfault.com/img/bVbCCMD)

## 对称加密和非对称加密

- 对称加密是最简单的方式，指的是加密和解密用的是同样的秘钥，优点是保证了消息的保密性，但缺点是密钥可能会泄露
- 非对称加密是说，如果有A、B两把密钥，用A加密过的数据包只能用B解密，反之用B加密的数据包只能由A解密，客户端在发消息的时候，先用公钥加密，服务器再用私钥解密。但是因为公钥不是保密的，可能会被窃取然后对消息进行篡改

## 数字证书和数字签名

为了解决非对称加密中公匙来源的不安全性。我们可以使用数字证书和数字签名来解决。

首先本地生成一对密钥，通过公钥去CA申请数字证书

- **数字签名**：CA拿到信息后会通过单向的hash算法把信息加密，然后生成一个摘要，然后CA会用自己的私钥对摘要进行加密，最后得出的结果就是数字签名了 

  ![image](https://user-gold-cdn.xitu.io/2017/10/16/6efb9ac7ac6baa22cd88fd35074f46b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  - **数字证书**：最后CA会将申请的信息还有数字签名整合在一起，就生成了数字证书了，其实也就是一个公钥 

  ![image](https://user-gold-cdn.xitu.io/2017/10/16/808f41fbb63ec6f3397288368160c7a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

- **数字证书如何起作用**：

1. 客户端用CA的公钥解密数字证书，如果数字证书来源合法，解密成功后，客户端就获得了信息摘要了。然后客户端会按照和CA一样的hash算法将申请信息生成一份摘要。
2. 然后和解密出来的那份摘要进行对比，如果内容完整，则说明没有被篡改。客户端就可以从证书中拿到**服务器的公钥和服务器进**行安全的非对称加密通信了。服务器要想获得客户端的公钥也可以通过这个方式![image](https://user-gold-cdn.xitu.io/2017/10/16/be5e7b8e6b17fed4edf31dbf4ee65117?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 握手过程

1. 客户端申请https通信。发送一个**随机数**，还有**加密方法**

2. 服务器响应然后向客户端**发送数字证书（公钥）**还有**随机数**给客户端

3. 客户端TLS验证证书，拿到公钥，如果没有问题就**生成一个随机值**，然后用**公钥加密**传给服务器

4. 服务器收到后用私钥解密，拿到了对称密钥，之后可以通过这个密钥进行信息传输了，然后建立SSL连接通道

5. 共享密钥交换成功，客户端和服务端开始加密通信

6. 断开连接 

   

```
客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥
服务器: 好的，这是我的证书，里面有加密后的公钥
客户端: 解密成功以后告诉服务器: 这是我的 (用公钥加密后的) 对称秘钥。
服务器: 好的，我知道你的秘钥了，后续就用它传输。
复制代码
```

### TSL1.2 DH握手

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6eee0152d64fa693667e9e40d96d0b~tplv-k3u1fbpfcp-watermark.image)

```
 1.浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。

// RSA
-2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件
-以及数字证书 (证书中附带公钥)。
// DH
+2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件
+以及数字证书 (证书中附带公钥)。
+同时服务器利用私钥将 client_random，server_random，server_params 签名，
+生成服务器签名。然后将签名和 server_params 也发送给客户端。 
+这里的 server_params 为 DH 算法所需参数。

// RSA
-3.浏览器接收，先验证数字证书。
-若通过，接着使用加密套件的密钥协商算法 RSA 算法
-生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
// DH
+3.浏览器接收，先验证数字证书和 _签名_。
+若通过，将 client_params 传递给服务器。
+这里的 client_params 为 DH 算法所需参数。

-4.服务器用私钥解密这个被加密后的 pre_random，参考 “非对称加密”。
+4.现在客户端和服务器都有 client_params、server_params 两个参数，
+因 ECDHE 计算基于 “椭圆曲线离散对数”，通过这两个 DH 参数就能计算出 pre_random。


```



## 使用

https加解密耗时比较长，也很消耗资源，如果不是安全性要求非常高可以不用。
