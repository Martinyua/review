

### 整个请求流程

1. 浏览器在加载资源时，会先判断是否命中强缓存，如果命中，就直接加载本地资源
2. 如果未命中，浏览器会发送一个请求到服务器，判断是否命中协商缓存。如果命中，服务器会返回这个请求，告诉浏览器直接使用本地请求。
3. 如果都没命中则直接从服务器加载资源

![](https://user-gold-cdn.xitu.io/2020/2/18/17057204e5e5fe54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 强缓存和协商缓存

|              | **获取资源形式** | **状态码**          | **发送请求到服务器**                       |
| ------------ | ---------------- | ------------------- | ------------------------------------------ |
| **强缓存**   | 从缓存取         | 200（from cache）   | 否，直接从缓存取                           |
| **协商缓存** | 从缓存取         | 304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |



### 强缓存

**强缓存**：浏览器**不会向服务器发送任何请求**，直接从本地缓存中读取文件并返回Status Code: 200 OK

与强缓存相关的**两个字段**：

**1. expires**（**http1.0)**:它的值为一个**绝对时间**的GMT格式的**时间字符串**,如果发送时间在expires之前，就使用本地缓存，否则发送到服务器来获取资源。

注意：它是一个绝对时间，Expires **受限于本地时间**，**如果修改了本地时间，可能会造成缓存失效**

   

2. **cache-control：max-age=number**（**http1.1**)：它是一个**相对值**。拿资源第一次请求的时间和cache-control设置的有效期来**计算一个过期时间**，然后拿这个时间和当前的请求时间做比较。

   cache-control还有其他的字段：

   * no-cache：不适用本地缓存
   * no-store：禁止浏览器缓存数据
   * public：可以被所有用户缓存，包括cdn和中间代理服务器
   * private：只能被终端用户缓存





### 协商缓存

协商缓存: 向服务器发送请求，服务器会根据这个请求的`request header`的一些参数来**判断是否命中协商缓存**，如果命中，则返回304状态码并带上新的`response header`通知浏览器从缓存中读取资源；



1. **Last-Modified/If-Modified-Since**（HTTP1.0）

   二者的值是GMT格式的时间字符串

   1. 浏览器在第一次请求的时候，**服务端会返回一个Last-Modified的字段**，表示这个资源在服务器上的**最后修改时间**
   2. 浏览器再次请求这个资源的时候，会在和header上加上If-Modified-Since的header，这个header的值就是上一次请求返回的Last-Modified的值。
   3. 服务器拿到这个这个值后和资源在服务器上的最后修改时间做比较，如果没有变化，就返回304 Not modified。并且从浏览器本地加载资源，不会更新Last-modified。
   4. 如果没有命中，浏览器直接从服务器加载资源，并且更新Last-Modified。

2. **`Etag/If-None-Match`**（HTTP1.1）

   这个值是由服务器生成的**对应每个资源的唯一标识符**，只要资源发生了改变，这个值就会改变。判断过程与`if-modified`类似。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于`ETag`重新生成过，response header中还会把这个`ETag`返回，即使这个`ETag`跟之前的没有变化。



### 为什么有了Last-Modified还有Etag

1. 有些文件只是修改时间发生了改变，但是内容没有发生改变
2. 某些服务器不能精确的获得文件的最后修改时间

